# 8-bit ALU with Status Flags on ESP32

This repository contains a software-based implementation of an **8-bit Arithmetic Logic Unit (ALU)** written in Embedded C.  
The project is designed to run in a hardware-agnostic simulation mode while remaining compatible with ESP32 and typical embedded C environments.  
It demonstrates how arithmetic and logical operations are computed along with hardware-style status flags such as Zero, Carry, Negative, and Overflow.

No external hardware or GPIO interface is required.  
All results are displayed through console logs to illustrate ALU behavior.

---

##  Project Overview

An ALU forms the computational core of a processor.  
This implementation models the essential operations of a real microcontroller ALU, making the project valuable for:

- Strengthening embedded systems fundamentals  
- Understanding processor arithmetic and logic operations  
- Demonstrating status flag computation  
- Learning bitwise manipulation and low-level C design  

The project uses clean modular code to represent how ALU components are structured inside embedded systems.

---

##  Supported Operations

The 8-bit ALU supports the following operations:

- **Addition (ADD)**
- **Subtraction (SUB)**
- **Bitwise AND**
- **Bitwise OR**
- **Bitwise XOR**
- **Shift Left Logical (SHL)**
- **Shift Right Logical (SHR)**

Each operation updates the ALU status flags accordingly.

---

##  Status Flags

The ALU computes four standard processor flags:

| Flag | Meaning |
|------|---------|
| **Z (Zero)**     | Result = 0 |
| **C (Carry)**    | Carry-out or borrow during arithmetic |
| **N (Negative)** | MSB = 1 (sign bit for signed numbers) |
| **V (Overflow)** | 2’s-complement overflow in ADD/SUB |

These flags match typical behavior found in ARM, AVR, and ESP32 ALUs.

---

##  Project Structure

The repository focuses only on the **core ALU logic** for clarity.  
A minimal build structure is used:

src/main.c → Runs ALU operations and prints results
src/alu.c → Implements ALU operations and flag computation
src/alu.h → Contains ALU function and flag declarations


No build-system files (CMakeLists, platformio.ini, sdkconfig) are included, keeping the project lightweight and implementation-focused.

---

##  Example Output (Console Simulation)

Example results generated by the ALU:

ADD 15 + 27 = 42 | Z=0 C=0 N=0 V=0
SUB 10 - 40 = 226 | Z=0 C=1 N=1 V=0
AND 0xF0 & 0x0F = 0x00 | Z=1 C=0 N=0 V=0
XOR 0x55 ^ 0xFF = 0xAA | Z=0 C=0 N=1 V=0
SHL 0x81 -> 0x02 | Z=0 C=1 N=0 V=0


All operations are executed in software to mimic standard processor ALU behavior.

---

##  Validation Approach

To verify correctness:

- Multiple operand pairs are tested for each operation  
- Edge cases such as 8-bit overflow and signed OV are included  
- Outputs are printed along with their flags for manual verification  

This mirrors how ALUs are validated during chip design or embedded system testing.

---

##  Purpose of This Repository

This project is optimized for:

- Academic and portfolio demonstration  
- Embedded C learning  
- Understanding bit manipulation and ALU architecture  
- Resume projects for embedded/firmware roles  
- ESP32-compatible algorithm design  

It does **not** require real hardware execution.

---

##  Possible Extensions

If desired, the ALU can be expanded with:

- Rotate operations (ROL, ROR)
- Arithmetic shift right (ASR)
- BCD arithmetic
- Instruction-level decoder
- FreeRTOS-based task scheduling of ALU operations

---

##  Author

Anjali 
Embedded Systems & Electronics Engineering

---

If this project helps you learn or reference ALU design, feel free to ⭐ star the repository!
